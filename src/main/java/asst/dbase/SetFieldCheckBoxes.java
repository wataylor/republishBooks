/* @name SetFieldCheckBoxes.java

    Copyright (c) 2002 by Advanced Systems and Software Technologies.
    All Rights Reserved<br>

    Under revision by: $Locker:  $<br>
    Change Log:<br>
    $Log: SetFieldCheckBoxes.java,v $
    Revision 1.9  2003/05/19 16:06:30  asst
    better error handling

    Revision 1.8  2002/09/12 04:49:57  asst
    documentation

    Revision 1.7  2002/09/05 02:14:42  asst
    added WriteLoneCheckbox method

    Revision 1.6  2002/08/18 03:38:08  asst
    documentation

    Revision 1.5  2002/08/12 18:04:44  zonediet
    added method to test a set string

    Revision 1.4  2002/06/17 17:13:46  zonediet
    documentation

    Revision 1.3  2002/05/12 00:48:12  zonediet
    comment typos

    Revision 1.2  2002/05/08 14:47:04  zonediet
    commented out a print statement

    Revision 1.1.1.1  2002/04/09 03:21:15  zonediet
    first import
<br>

*/

package asst.dbase;

import javax.servlet.http.HttpServletRequest;

import java.sql.*;

import asst.dbase.DataBase;
import asst.dbase.SQLUtilities;

/**
 * These utilities implement a "Set" which is stored as a string.
 * Each character of the string represents a set member; a value of
 * "Y" indicates that the set contains the member associated with that
 * character of the string and any other value indicates that it does
 * not.  Any set member whose subscript extends beyond the length of
 * the string is considered to be absent from the set.</p>

 * <P>As defined, the set may include any combination of members.  It
 * is up to the caller to restrict the set to one member if that is
 * required.  In this case, however, it might be better to use radio
 * buttons which can be generated by

{@link asst.dbase.SelectorRadioPreload}.</p>

 * <P>Human-readable strings which label the meanings of the characters
 * in the string and integer constants which select characters for
 * testing are generally maintained in calling classes.</p>

 * @author Web Work
 * @version %I%, %G%
 * @since
 *
 */

public class SetFieldCheckBoxes {

  /** One instance of the empty string is enough.*/
  public static final String ES = "";

  /** Obligatory constructor.  */
  public SetFieldCheckBoxes() {
  }

/**
 * Return a string containing the checkbox values as specified in a
 * form given the prefix for naming the checkboxes, the length of the
 * array which labeled the checkboxes, and the request.  This method
 * is the inverse of

{@link asst.dbase.SetFieldCheckBoxes#WriteCheckBoxSet(String settings, String prefix, String[] labelArray, String title) WriteCheckBoxSet}.

 * It is up to the methods which create the form to guarantee unique
 * prefixes for each set in the form and to make sure that sets are
 * read and written using the same prefix.</p>

 * <P>It does not matter whether the checkboxes are written into the form
 * as one group or separately so long as all checkboxes use the same prefix.
 * A set member is set to "n" if its field is
 * not found in the form.

 @param prefix is the string which is prepended to the checkbox number
 to make it unique in case there is more than one set in the current
 form.
 @param arrayLength length of the array of strings which labeled the
 checkboxes.
 @param request servlet request which has the values of the
 checkboxes as set in the form.
 @return string value of the set as specified in the form, generally used to
 set the dirty choice in a selector field.  */

  public static String ReadCheckBoxSet(String prefix, int arrayLength,
				       HttpServletRequest request) {
    StringBuffer sb = new StringBuffer();
    int i;
    /**/

    for (i=0; i<arrayLength; i++) {
      if (request.getParameter(prefix + i) != null) {
	sb.append("Y");
      } else {
	sb.append("n");
      }
    }
    return sb.toString();
  }

/**
 * Create a .html string which defines checkboxes for all Y or N
 * fields defined by a label array passed to it.  This method is the
 * inverse of

{@link asst.dbase.SetFieldCheckBoxes#ReadCheckBoxSet(String prefix, int arrayLength, HttpServletRequest request) ReadCheckBoxSet}.

 * It is
 * up to the methods which create the form to guarantee unique
 * prefixes for each set in the form and to make sure that sets are
 * read and written using the same prefix.  If the string is too
 * short, members beyond the length of the string are treated as "n".
 * A table title is generated if the title is non-null.</p>

 *<P>This routine returns a StringBuffer instead of a String because
 *StringBuffer is an acceptable servlet output parameter.

 @param settings String representation of the current state of the
 set, Y represents a checked checkbox, anything else is an un-checked
 checkbox.
 @param prefix is the string which is prepended to the checkbox number
 to make it unique in case there is more than one set in the current
 form.
 @param labelArray array of strings to label the checkboxes.  It is up
 to the caller to implement a meaningful relationship between the
 labels and how the corresponding set elements are used.
 @param title title for the table to be generated.
 @return string buffer which contains the checkbox definitions.  */

  public static StringBuffer WriteCheckBoxSet(String settings, String prefix,
					      String[]labelArray, String title)

    {
    StringBuffer sb = new StringBuffer();
    int i;			// Count the members

    sb.append("<TABLE>");
    if (title != null) {
      sb.append("<TR><TH ALIGN=\"center\">" + title + "</th></tr>\n");
    }

    for (i=0; i<labelArray.length; i++) {
      sb = WriteOneCheckBox(settings, prefix, labelArray, i, sb);
    }
    sb.append("</table>\n");
    return sb;
    }

/**
 * Create a .html string which defines checkboxes for a range of Y or
 * N fields defined by a label array passed to it.  The range accepts
 * the usual comma-delimited or hyphen-ranged inidicators, as used for
 * specifying page ranges in Print dialogs.  Generally the particular
 * index numbers to be used in the range will be found in the relevant
 * constants file.  It is up to the methods which create the form to
 * guarantee unique prefixes for each set in the form and to make sure
 * that sets are read and written using the same prefix.  If the
 * string is too short, members beyond the length of the string are
 * treated as "n".  A table title is generated if the title is
 * non-null.</p>

 *<P>This routine returns a StringBuffer instead of a String because
 *StringBuffer is an acceptable servlet output parameter.

 @param settings String representation of the current state of the
 set, Y represents a checked checkbox, anything else is an un-checked
 checkbox.
 @param prefix is the string which is prepended to the checkbox number
 to make it unique in case there is more than one set in the current
 form.
 @param labelArray array of strings to label the checkboxes.  It is up
 to the caller to implement a meaningful relationship between the
 labels and how the corresponding set elements are used.
 @param title title for the table to be generated.
 @param which dash and comma-separated list of indexes into the set
 values and label array; selected checkboxes are generated into the
 table.
 @return string buffer which contains the checkbox definitions.  */

  public static StringBuffer
  WriteSomeCheckBoxes(String settings, String prefix, String[]labelArray,
		      String title, String which) {
    StringBuffer sb = new StringBuffer();
    int i;			// Look for numbers
    char ch;			// One character from the string
    String accum = null;
    int start = -1;
    int j;

    sb.append("<TABLE>");
    if (title != null) {
      sb.append("<TR><TH ALIGN=\"center\">" + title + "</th></tr>\n");
    }

    for (i=0; i<which.length(); i++) {
      ch = which.charAt(i);
      if (Character.isWhitespace(ch)) {
	continue;
      }
      if (ch == ',') {
	continue;
      }
      if (Character.isDigit(ch)) {
	accum = String.valueOf(ch);
	try {
	  ch = which.charAt(i+1);
	    while (Character.isDigit(ch)) {
	      i++;
	      accum += String.valueOf(ch);
	      ch = which.charAt(i+1);
	    }
	} catch (Exception e) {}

	if (start >= 0) {
	  for (j=start+1; j<Integer.parseInt(accum); j++) {
	    WriteOneCheckBox(settings, prefix, labelArray, j, sb);
	  }
	  start = -1;
	}

	WriteOneCheckBox(settings, prefix, labelArray,
			 Integer.parseInt(accum), sb);
      }
      if (ch == '-') {
	if (accum == null) {
	  start = 0;
	} else {
	start = Integer.parseInt(accum);
	}
      }
    }
    sb.append("</table>\n");
    return sb;
  }

/**
 * Create a .html string which defines ONE Y or N field contained
 * within a label array passed to it without generating any table row
 * definitions.

 @param settings String representation of the current state of the
 set, Y represents a checked checkbox, anything else is an un-checked
 checkbox.
 @param prefix is the string which is prepended to the checkbox number
 to make it unique in case there is more than one set in the current
 form.
 @param labelArray array of strings to label the checkboxes.  It is up
 to the caller to implement a meaningful relationship between the
 labels and how the corresponding set elements are used.
 @param arrayIndex index into the settings string and into the label
 array.
 @return string which defines the check box.*/

  public static String WriteLonelyCheckBox(String settings,
					   String prefix,
					   String[]labelArray,
					   int arrayIndex) {
    String chk;			// Checked indication
    char ch;			// One character from the string
    /**/

    try {
      ch = settings.charAt(arrayIndex);
    } catch (StringIndexOutOfBoundsException e) { ch = 'n'; }
    if (ch == 'Y') {
      chk = " checked";
    } else {
      chk = ES;
    }
    return ("<input type=\"checkbox\" name=\"" + prefix + arrayIndex +
	      "\"" + chk + ">" + labelArray[arrayIndex] + "\n");
  }

/**
 * Create a .html string which defines a table row containing ONE Y or
 * N field contained within a label array passed to it.  This method
 * generates table rows but assumes the calling method has wrapped the
 * TABLE statements around them.

 * <P>This routine modifies and returns a StringBuffer containing the
 * table being generated.

 @param settings String representation of the current state of the
 set, Y represents a checked checkbox, anything else is an un-checked
 checkbox.
 @param prefix is the string which is prepended to the checkbox number
 to make it unique in case there is more than one set in the current
 form.
 @param labelArray array of strings to label the checkboxes.  It is up
 to the caller to implement a meaningful relationship between the
 labels and how the corresponding set elements are used.
 @param arrayIndex index into the settings string and into the label
 array.
 @param sb string buffer to which the checkbox definition is
 appended.
 @return augmented string buffer.*/

  public static StringBuffer WriteOneCheckBox(String settings, String prefix,
				      String[]labelArray,
				      int arrayIndex, StringBuffer sb) {
    String chk;			// Checked indication
    char ch;			// One character from the string
    /**/

    try {
      ch = settings.charAt(arrayIndex);
    } catch (StringIndexOutOfBoundsException e) { ch = 'n'; }
    if (ch == 'Y') {
      chk = " checked";
    } else {
      chk = ES;
    }
    sb.append("<TR><TD><input type=\"checkbox\" name=\"" + prefix +
	      arrayIndex +
	      "\"" + chk + ">" + labelArray[arrayIndex] + "</td></tr>\n");
    return sb;
  }

  /** Return the index of the first Y in a string or zero if the
      string is null or if there is no Y in it. */
  public static int firstYInSet(String setS) {
    int i;
    try {
      for (i=0; i<setS.length(); i++) {
	if (setS.charAt(i) == 'Y') { return i; }
      }
    } catch (Exception e) {}
    return 0;
  }

  /** Return the index of the last Y in a string, returning zero if the
      string is null or if there is no Y in it.
  @param setS String representation of the set.
  @return index of the last Y in the set or 0.*/
  public static int lastYInSet(String setS) {
    int i;
    try {
      for (i=setS.length()-1; i>0; i--) { // >0 is actually correct....
	if (setS.charAt(i) == 'Y') { return i; }
      }
    } catch (Exception e) {}
    return 0;
  }

  /** Update a table by setting a selected member of a set to some
      value and return the new value of the set.  The set is
      lengthened with 'n' if it is too short to hold the indicated
      value.  The table is not updated if the operation does not
      change the value of the set string.

  @param id numerical ID of the record in the table.
  @param table name of the SQL table which holds the set to be updated.
  @param column name of the column within the table which holds the
  set being updated.
  @param which integer which indicates the set member which is to
  receive a new value.  It is up to the caller to ensure that this
  results in a string which fits into the database column without
  being truncated.
  @param value new value for the set member, anything other than 'Y'
  is false.
  @return the updated value of the set string.*/
  public static String setASet(int id, String table, String column,
			       int which, char value) {
    Statement stmt    = null;
    ResultSet results = null;
    String setValue   = ES;
    String query;
    char[] statChars;		// Status string as a character array
    /**/

    if (id <= 0) return ES;

    try {
      stmt  = DataBase.connDB.createStatement();
      query = "select " + column + " from " + table + " where ID = " + id;
      //System.out.println(query);
      results = stmt.executeQuery(query);
      if (results.next()) {
	setValue = SQLUtilities.stringFromResult(results, 1);
	while (setValue.length() <= which) { setValue = setValue + "n"; }
	statChars = setValue.toCharArray();
	try {
	  if (statChars[which] == value) { return setValue; } // already good
	  statChars[which] = value;
	} catch (Exception e) {}
	setValue = new String(statChars);
	query = "update " + table + " set " + column + "='" + setValue +
	  "' where ID=" + id;
	//System.out.println(query);
	stmt.execute(query);
      }
    } catch (SQLException e) {
      throw new RuntimeException("setASet excp " + e.toString());
    } finally {
      try {
	if (results != null) { results.close(); }
	if (stmt    != null) { stmt.close(); }
      } catch (SQLException e) {}
    }
    return setValue;
  }

  /** Read a set from a table return the value of the set; this may be
the empty string but will not be null.

  @param id numerical ID of the record in the table.
  @param table name of the SQL table which holds the set to be updated.
  @param column name of the column within the table which holds the
  set being updated.
  @return the current value of the set.*/

  public static String getASet(int id, String table, String column)
    throws SQLException {
    Statement stmt    = null;
    ResultSet results = null;
    String setValue   = ES;
    String query;
    char[] statChars;		// Status string as a character array
    /**/

    if (id <= 0) return ES;

    try {
      stmt  = DataBase.connDB.createStatement();
      query = "select " + column + " from " + table + " where ID = " + id;
      System.out.println(query);
      results = stmt.executeQuery(query);
      if (results.next()) {
	setValue = SQLUtilities.stringFromResult(results, 1);
      }
    } finally {
      if (results != null) { results.close(); }
      if (stmt    != null) { stmt.close(); }
    }
    return setValue;
  }

  /** Write a set to a table, the set string passed in replaces the
   * string in the table.

  @param id numerical ID of the record in the table.
  @param table name of the SQL table which holds the set to be updated.
  @param column name of the column within the table which holds the
  set being updated.
  @param set string representing the set content to be written.  */

  public static void setASet(int id, String table, String column, String set)
    throws SQLException {
    Statement stmt    = null;
    String query;
    char[] statChars;		// Status string as a character array
    /**/

    if (id <= 0) return;

    try {
      stmt  = DataBase.connDB.createStatement();
      query = "update " + table + " set " + column + "=" + set +
	" where  ID = " + id;
      System.out.println(query);
      stmt.execute(query);
    } finally {
      if (stmt    != null) { stmt.close(); }
    }
  }

  /** Determine whether a set has a specific member or not.  Being set
  requires that the specified column contain a "Y"; if the string is
  too short or the character contains other than Y, the result is
  false.
  @param member integer representing a specific set member, it should
  probably be defined as an application-dependent constant.
  @param setS String representation of the set.
  @return true -> the set has the specified member. */
  public static boolean SetHasMemberP(int member, String setS) {
    /**/

    if (setS == null) { return false; }

    try {
      if (setS.charAt(member) == 'Y') { return true; }
    } catch (StringIndexOutOfBoundsException e) {}
    return false;
  }
}
