/* @name SelectorFieldPreload.java

Implement a selection object which operates from a text field.  In
this case, the user types in an arbitrary value rather than selecting
from a predefined list.

    Copyright (c) 2001 by Advanced Systems and Software Technologies.
    All Rights Reserved<br>

    Under revision by: $Locker:  $<br>
    Change Log:<br>
    $Log: SelectorFieldPreload.java,v $
    Revision 1.21  2007/05/15 01:56:20  asst
    documentation

    Revision 1.20  2006/01/19 16:40:54  asst
    read-only attribute for fields and forms

    Revision 1.19  2003/02/11 16:49:19  asst
    added type=text to generated .html

    Revision 1.18  2003/02/08 14:56:29  asst
    automatic SQL wildcards in where string

    Revision 1.17  2002/12/17 03:50:22  asst
    documentation

    Revision 1.16  2002/11/24 04:07:30  asst
    empty field overrides null in choice field

    Revision 1.15  2002/10/16 01:23:12  asst
    documentation

    Revision 1.14  2002/10/15 05:30:24  asst
    documentation, getEditableOrFixed()

    Revision 1.13  2002/10/06 01:36:46  asst
    first upload

    Revision 1.12  2002/09/20 21:41:21  asst
    testCharacterOfChoice

    Revision 1.11  2002/09/13 03:28:03  asst
    date format, set character of choice

    Revision 1.10  2002/09/12 04:52:57  asst
    added RadioSet, CheckboxSet, RadioSetMember

    Revision 1.9  2002/09/08 03:03:05  asst
    documentation

    Revision 1.8  2002/09/08 02:57:01  asst
    Separated date and password classes

    Revision 1.7  2002/09/05 02:14:10  asst
    typos

    Revision 1.6  2002/09/04 21:33:35  asst
    Added text-only methods, error string and flag

    Revision 1.5  2002/07/13 17:56:05  zonediet
    documentation

    Revision 1.4  2002/06/26 02:07:32  zonediet
    Date fields leave choice alone if not in form

    Revision 1.3  2002/04/30 15:36:04  zonediet
    Selector managers do any year, begin and end times

    Revision 1.2  2002/04/11 03:22:44  zonediet
    Added date type selector field

    Revision 1.1.1.1  2002/04/09 03:20:31  zonediet
    first import
 */

package asst.dbase;

import java.text.SimpleDateFormat;

import java.util.Vector;
import java.util.Calendar;
import java.util.GregorianCalendar;

import javax.servlet.http.HttpServletRequest;

import asst.dbase.makeHtmlTables;
import asst.dbase.SelectorManager;
import asst.dbase.StringSetUtils;

import asst.time.MonthDayNames;

/**
 * Implementation of the SelectorManager interface which reads its
 * input state from a .html input field object.

 * Selector manager objects can be rather complicated, there are code
 * fragments showing how to use two of the most complex managers in

 {@link asst.dbase.SelectorRadioSet} and
 {@link asst.dbase.SelectorCheckboxSet}

 * @author money
 * @version %I%, %G%
 * @since

 @see asst.dbase.ChangeLog

 */

public class SelectorFieldPreload implements SelectorManager {

  /** No-arg constructor which sets the default choice to null. */
  public SelectorFieldPreload() {
  }

  /**
   * Constructor that sets the field name, database table name, and
   * database column.  Strictly speaking, the database parameters are
   * irrelevant to a text box selector, but the data are carried along
   * in case the application wishes to associate the selector with a
   * database table after data are entered.

   * SelectorManagers are usually stored in an array which makes up a
   * form.  ALthough it would be possible to manipulate these objects
   * based on their array subscript, it is usually more convenient to
   * instantiate them thus:

   * <pre><code>
   * SelectorManager[] form = new SelectorManager[number of fields];
   * SelectorManager aField;
   * ...
   * form[5] =
  (aField = new SelectorFieldPreload(&lt;name&gt;,&lt;table&gt;,&lt;column&gt;));
   * </code></pre>

   * The SelectorManager defined thus may be manipulated either as
   * <CODE>aField</code> or as <CODE>form[5]</code>.

   * @param name The name by which the form field generated by getHTML
   * is identified; this name has NOTHING to do with the database.
   * This name is used when retrieving the current user-entered value
   * from the form.  Spaces are converted to underscores so that Java
   * Script can reference the form value.  If spaces are required in
   * the form, the method {@link #getPrettyName()} should be used to
   * retrieve a human-readable name from this field.

   * @param table The name of the database table in which the field is
   * generally stored.  This table is expected to be indexed by a
   * field which is to be passed to TwixtTableAndForm.

   * @param column The name of the database colun within the table
   * which stores the field value.  The column is assumed to store
   * character data; if the column is numeric, the setNumericFlag
   * method must be called to set the numeric flag true so that the
   * proper SQL can be generated by TwixtTableAndForm.

  */
  public SelectorFieldPreload(String name, String table, String column) {
    this.setName(name);
    this.table = table;
    this.column = column;
  }

  public boolean getReadOnly() { return this.readOnly; }
  public void setReadOnly(boolean readOnly) { this.readOnly=readOnly; }

  public StringBuffer getHTML() {
    return this.getHTML(20);
  }

  public StringBuffer getHTML(int width) {
    StringBuffer sb;
    /**/

    sb = new StringBuffer(this.getPrettyName() + ": ");
    if (readOnly) {
      sb.append(getChoiceAsText()); // Uneditable
    } else {
      sb.append(this.getHTMLOnly(width));
    }
    return sb;
  }

  public StringBuffer getHTML(int width, int height) {
    StringBuffer sb;
    /**/

    sb = new StringBuffer(this.getPrettyName() + ": ");
    if (readOnly) {
      sb.append(getChoiceAsText()); // Uneditable
    } else {
      sb.append(this.getHTMLOnly(width, height));
    }
    return sb;
  }

  public StringBuffer getHTMLOnly() {
    if (readOnly) return new StringBuffer(getChoiceAsText());
    return this.getHTMLOnly(20);
  }

  public StringBuffer getHTMLOnly(int width) {
    StringBuffer sb;
    String cho = ES;
    /**/

    if (readOnly) return new StringBuffer(getChoiceAsText());

    if (this.choice != null) {
      cho = this.choice;
    }
    sb = new StringBuffer("<input type=\"text\" name=\"" +
			  this.fieldNamePrefix + this.name +
			  "\" size=\"" + width +
			  "\" value=\"" + cho + "\"" + this.addParam + ">");
    return sb;
  }

  public StringBuffer getHTMLOnly(int width, int height) {
    StringBuffer sb;
    /**/

    if (readOnly) return new StringBuffer(getChoiceAsText());

    sb = new StringBuffer("<textarea name=\"" +
			  this.fieldNamePrefix + this.name +
			  "\" cols=\"" + width +
			  "\" rows=\"" + height + "\"" + this.addParam + ">");
    if (this.choice != null) {
      sb.append(this.choice);
    }
    sb.append("</textarea>");
    return sb;
  }

  /** Safely convert a string to an integer, returning 0 in case of
      difficulty.*/
  public static int IntegerFromString(String val) {
    try {
      return Integer.parseInt(val);
    } catch (Exception e) {
    }
    return 0;
  }

  public boolean getKnowsChoice() {
    return ((this.choice != null) && (!ES.equals(this.choice)));
  }

  public void setChoice(String choice) {
    this.choice = choice;
    this.priorChoice = choice;
    this.dirty = false;
    this.errorFlag = false;
  }

  public void setDirtyChoice(String aParam) {

    if (aParam==null) { return; }

//     if (this.choice == null) {	// Empty field does not change null in form
//       if (ES.equals(aParam)) { return; }
//     }

    if (!aParam.equals(this.choice)) {
      this.dirty=true;
      this.choice = aParam;
    }
  }

  public void setCharacterOfChoice(int which, char ch) {
    this.setDirtyChoice(StringSetUtils.SetASetStringMember(this.getChoice(),
							   which, ch));
  }

  public boolean testCharacterOfChoice(int which) {
    return StringSetUtils.TestASetStringMember(this.getChoice(), which);
  }

  public void setChoice(HttpServletRequest request) {
    String aParam;
    /**/

    aParam = request.getParameter(this.fieldNamePrefix + this.name);
    //System.out.println(this.name + " " + aParam);
    this.setDirtyChoice(aParam);
  }

  public void setFreeWildcard(boolean is) {
    this.freeWildcard = is;
  }

  public boolean getFreeWildcard() {
    return this.freeWildcard;
  }

  public void setIsInForm(boolean is) {
    this.isInForm = is;
  }

  public boolean getIsInForm() {
    return this.isInForm;
  }

  public String getEditableOrFixed() {
    if (this.isInForm) return getHTMLOnly().toString();
    return getChoiceAsText();
  }

  public boolean getDirtyFlag() {
    return this.dirty;
  }

  public void setDirtyFlag(boolean dirty) {
    this.dirty = dirty;
  }

  public boolean getIsLogged() { return this.isLogged; }

  public void setIsLogged(boolean logged) { this.isLogged = logged; }

  public boolean getErrorFlag() { return this.errorFlag; }

  public void setErrorFlag(boolean error) { this.errorFlag = error; }

  public void setErrorString(String errorMessage) {
    this.errorMessage = errorMessage;
  }

  public String getErrorString() {
    if (!this.errorFlag) {
      return SelectorFieldPreload.ES;
    }
    return this.errorMessage;
  }

  public String getFieldNamePrefix() {
    return this.fieldNamePrefix;
  }

  public void setFieldNamePrefix(String prefix) {
    this.fieldNamePrefix = prefix;
  }

  public boolean getUniqueFlag() {
    return this.unique;
  }

  public void setUniqueFlag(boolean unique) {
    this.unique = unique;
  }

  public void setIsUnique(boolean unique) {
    this.unique = unique;
  }

  public boolean getIsValid() {
    return !(this.choice == null);
  }

  public void setNumericFlag(boolean numeric) {
    this.numeric = numeric;
  }

  public void setIsNumeric(boolean numeric) {
    this.numeric = numeric;
  }

   public boolean getNumericFlag() {
    return this.numeric;
  }

  public String getPriorChoice() {
    return ((this.priorChoice == null) ? ES : this.priorChoice);
  }

  public String getChoice() {
    return ((this.choice == null) ? ES : this.choice);
  }

  public String getChoiceAsText() {
    return this.getChoice();
  }

  public void setName(String name) {
    this.name = name.replace(' ', '_');
  }

  public String getName() {
    return this.name;
  }

  public String getPrettyName() {
    return this.name.replace('_', ' ');
  }

   public void setTable(String table) {
    this.table = table;
  }

  public String getTable() {
    return this.table;
  }

  public void setColumn(String column) {
    this.column = column;
  }

  public String getColumn() {
    return this.column;
  }

  public void setAddParam(String param) {
    if (param.startsWith(" ")) {
      this.addParam = param;
    } else {
      this.addParam = " " + param;
    }
  }

  public String getAddParam() {
    return this.addParam;
  }

  /** Name of the selector, this becomes the documentation for the
    selector in the .html "Select a <name>:" when the selector is put
    into the page.  This name must not include spaces in cases where
    java script is used to validate the field on submit; that is why
    the <CODE>getPrettyName</code> method converts underscores in the
    name to spaces.  */
  protected String name;

  /** The selected choice from the selection or a new value entered
      into the field.  A choice has not yet been made if this is null
      or "".  The <CODE>getChoice()</code> method returns "" rather
      than null even when a choice has not been made.  */
  protected String choice;

  /** The original field value.  This value is logged as the prior
   * value when the <CODE>isLogged flag</code> is set and the value
   * changes.  */
  protected String priorChoice;

  /** The name of the database table from which the selection values
      come or the name of the table with which the choice field is
      associated. */
  protected String table;

  /** The name of the database table column from which the selection
      values come or the name of the column with which the choice
      field is associated. */
  protected String column;

  /** Record whether the value has been changed since it was loaded
      from the database. */
  protected boolean dirty;

  /** Record whether the column value is supposed to be unique within the
      database table. */
  protected boolean unique = false;;

  /** Record whether changes in the column value should be logged
   * automatically.*/
  protected boolean isLogged = false;

  /** Record the field name prefix which differentiates the same field
      from different rows.*/
  protected String fieldNamePrefix = ES;

  /** Record that the database column is stored as numeric; this
      affects how the string is handled when it is put into the
      database.  This does not affect taking data out of the database;
      any column can be extracted from the result set as a string. */
  protected boolean numeric;

  /** Additional parameter inserted inside the .html object when it is
      generated.  It defaults to the empty string.  It is up to the
      caller to ensure that this parameter is compatible with the rest
      of the generated .html, including providing any spaces which may
      be required after the value. */
  protected String addParam=ES;

  /** Error message*/
  protected String errorMessage = ES;

  /** Error flag*/
  protected boolean errorFlag = false;

  /** Empty string.  */
  public static final String ES = "";

  /** String which indicates that there are no selections.  */
  public static final String NO_SEL = "No Selections";

  /** SQL-specific date formatter for date selector.  This format
   * string must match the code in {@link
   * asst.time.TimeUtils#PreparedCal PreparedCal} and in {@link
   * asst.time.TimeUtils#PreparedCalSecs PreparedCalSecs}.*/
  public static final SimpleDateFormat SQL_DATE_STRING =
  new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");

  /** Record whether the set has been put in the form or not.  This
   * flag is ignored by Radio sets but is provided for compatibility
   * with Checkbox sets.  It also affects the operation of the
   * <CODE>getEditableOrFixed</code> method.
   @see asst.dbase.SelectorRadioSet
   @see asst.dbase.SelectorRadioSetMember
   @see asst.dbase.SelectorCheckboxSet
*/
  protected boolean isInForm;

  /** Record whether the field should have free wild cards surrounding
   * it when used in a search form.
   @see asst.dbase.TwixtTableAndForm*/
  protected boolean freeWildcard;

  /**
   * Record whether the field should be editable or read only. */
  protected boolean readOnly;

}
