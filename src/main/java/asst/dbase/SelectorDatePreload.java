/* @name SelectorDatePreload.java

    Copyright (c) 2002 by Advanced Systems and Software Technologies.
    All Rights Reserved<br>

    Under revision by: $Locker:  $<br>
    Change Log:<br>
    $Log: SelectorDatePreload.java,v $
    Revision 1.10  2006/01/19 16:40:54  asst
    read-only attribute for fields and forms

    Revision 1.9  2005/03/22 19:48:44  asst
    date selector returns 0 when empty

    Revision 1.8  2004/01/31 22:41:57  asst
    fix use of anyParam

    Revision 1.7  2003/10/06 20:52:31  asst
    pop-up calendar

    Revision 1.6  2003/03/05 18:51:33  asst
    blank fields if date string starts with 0

    Revision 1.5  2002/11/24 04:06:58  asst
    methods to move time by days or any field

    Revision 1.4  2002/10/16 01:22:06  asst
    Made year an optional selection list

    Revision 1.3  2002/09/22 03:58:30  asst
    display null dates more sensibly

    Revision 1.2  2002/09/13 03:27:23  asst
    change internal date choice format to JDBC string

    Revision 1.1  2002/09/08 02:57:01  asst
    Separated date and password classes
<br>

*/

package asst.dbase;

import java.text.NumberFormat;

import java.util.Date;
import java.util.Calendar;
import java.util.GregorianCalendar;

import javax.servlet.http.HttpServletRequest;

import asst.dbase.SelectorFieldPreload;
import asst.time.MonthDayNames;

/**
 * Selector field which is automatically formatted as a date.  The
 * year can be formatted either as a text field or as a pulldown; in
 * the latter case, the first and last years of the pulldown must be
 * specified.</p>

 * <P>A given date may either begin an interval in which case the
 * hour, minuts, and second are set to zero, or it may end an interval
 * in which case the hour, minute, and second are set to 23:59:59.
 * This supports time comparison both in SQL columns or in Java
 * <CODE>Date</code> or <CODE>Calendar</code> objects.</p>

 <P>The <CODE>addParam</code> string is applied to all fields.

 * @author money
 * @version %I%, %G%
 * @since
 *
 * @see <classname>
 */

public class SelectorDatePreload extends SelectorFieldPreload {

  /** Format a single-digit number with a leading zero.*/
  public static NumberFormat LZERO_NUMBER = NumberFormat.getInstance();
  static {
    LZERO_NUMBER.setMinimumIntegerDigits(2);
  }

  /** Obligatory constructor.*/
  public SelectorDatePreload() {
  }

  /**
   * Constructor that sets the field name, database table name, and
   * database column.

   * @param name The name by which the form field generated by getHTML
   * is identified; this name has NOTHING to do with the database.
   * This name is used when attempting to retrieve the current
   * user-entered value from the form.  This name should not contain
   * spaces if the fields are to be manipulated by JavaScript.  If
   * spaces are simulated by underscores, the method getPrettyName
   * should be used to retrieve a human-readable name from this field.

   * @param table The name of the database table in which the field is
   * stored.  This table is expected to be referenced by a
   * field which is to be passed to TwixtTableAndForm.

   * @param column The name of the database column within the table
   * which stores the field value.  The column is assumed to store
   * character data because SQL TIMESTAMP columns are updated as if
   * they were character constants.  The choice is stored as an SQL
   * time string in JDBC escape format which is yyyy-mm-dd hh:mm:ss
   * This format is enforced by {@link
   * asst.dbase.SelectorFieldPreload#SQL_DATE_STRING}

  */
  public SelectorDatePreload(String name, String table, String column) {
    super(name, table, column);
  }

  /** Read a set of selectors which set a date.
   @param name is the name of the set of selectors, various strings
   are added to the name to read the request.
   @param request the servlet request object from which values are extracted.*/
  public String ReadDateSelectors(String name, HttpServletRequest request,
				  boolean begins) {
    String answer;
    String yr;
    String mo;
    String da;
    /**/

    yr=request.getParameter(name+"_yR");
    mo=request.getParameter(name+"_mO");
    da=request.getParameter(name+"_dA");

    if ((yr == null) || ES.equals(yr) ||
	(mo == null) || ES.equals(mo) ||
	(da == null) || ES.equals(da)) { return null; } // Nothing set in form

    answer = yr + "-" + mo + "-" + da + " ";

    if (begins) {
    // Begins an interval
      answer += "00:00:00";
    } else {
    // ends an interval
      answer += "23:59:59";
    }

//      System.out.println(name + " " + yr + " " + mo + " " + da + " " +
//                     begins + " " + answer);

    return answer;
  }

  /** Return a set of selectors for the date.  Expects a string of the
      form yyyy-mm-dd hh:mm:ss as generated by {@link
      asst.dbase.SelectorFieldPreload#SQL_DATE_STRING}

  @param Yyyymmdd gives the current value of the selection.
  @param name is the .html field name to which are postpended identifiers.
  @return .html date selectors which suffice to select a day.*/
  public StringBuffer MakeDateSelectors(String Yyyymmdd, String name,
					int fY, int eY) {
    Date dat;
    String yr;
    String mos;
    String das;
    int mo;
    int da;
    int yrInt;
    StringBuffer sb = new StringBuffer();
    int i;
    /**/

    if (Yyyymmdd.startsWith("0")) { Yyyymmdd = ES; }

    try { yr = Yyyymmdd.substring(0, 4); } catch (Exception e) { yr = ES; }

    if ((fY == 0) && (eY == 0)) {
      // Generate year as a field
      sb.append("<input name=\"" + name + "_yR\" size=\"4\" value=\"" +
		yr + "\"");
      if (usePopUp) {
	sb.append(" onKeyPress='return justNums(event,this)' onKeyUp='checkYear(this)'");
      }
      sb.append(this.addParam + ">\n");
    } else {
      // Generate year as a selector
      yrInt = SQLUtilities.integerFromString(yr);
      sb.append("<SELECT NAME=\"" +  name + "_yR\"" + this.addParam + ">\n");
      if (yrInt == 0) {
	sb.append("<OPTION selected VALUE=\"\">Make A Selection</option>\n");
      } else {
	sb.append("<OPTION VALUE=\"\">Make A Selection</option>\n");
      }
      for (i=fY; i<=eY; i++) {
	sb.append("<OPTION VALUE=\"");
	sb.append(i + "\"");
	if (yrInt == i) { sb.append(" selected"); }
	sb.append(">" + i + "</option>\n");
      }
      sb.append("</select>\n");
    }
//Generate months as a selector
    sb.append("<SELECT NAME=\"" + name + "_mO\"" + this.addParam + ">\n");
    try {
      mos = Yyyymmdd.substring(5, 7);
      mo = Integer.parseInt(mos);
      if (--mo < 0) { mo = 0; }	// Array of names is zero-based
    } catch (Exception e) { mo = 0; }
    for (i = 0; i < MonthDayNames.MONTH_NAMES.length; i++) {
      sb.append("<OPTION VALUE=\"");
      if (i < 9) sb.append("0");
      sb.append((i+1) + "\"");
      if (mo == i) { sb.append(" selected"); }
      sb.append(">" + MonthDayNames.MONTH_NAMES[i] + "</option>\n");
    }
    sb.append("</select>\n");

    try {
      das = Yyyymmdd.substring(8, 10);
      if ( (da = Integer.parseInt(das)) < 1) { da = 1; }
    } catch (Exception e) { da = 1; }

    if (usePopUp) {
//Generate day/date as a text field
      sb.append("<input type=\"text\" size=\"2\" name=\"" + name +
		"_dA\" value=\"" + da + "\" onKeyPress='return justNums(event,this)' onKeyUp='checkDay(this)'" + this.addParam + ">\n");
    } else {
//Generate day/date as a selector
      sb.append("<SELECT NAME=\"" + name + "_dA\"" + this.addParam + ">\n");
      for (i = 1; i <=31; i++) {
	sb.append("<OPTION VALUE=\"");
	if (i <= 9) sb.append("0");
	sb.append( i + "\"");
	if (da == i) { sb.append(" selected"); }
	sb.append(">" + i + "</option>\n");
      }
      sb.append("</select>\n");
    }

    if (usePopUp) {
      try {
	dat = SQL_DATE_STRING.parse(Yyyymmdd);
	yr = ES + dat.getTime();
      } catch (Exception e) { yr = ES; }

      sb.append("<input type=\"hidden\" name=\"" + name + "_mS\" value=\"" +
		yr + "\">\n<a href=\"javascript:" + name+
		"_cal.popup(document." + formName + "." + name +
		"_mS);\"><img src=\"popcalimg/cal.gif\" width=\"16\" height=\"16\" border=\"0\" alt=\"Click here to set the date\"></a>\n");
      sb.append("<script language=\"JavaScript\">\nvar " + name +
		"_cal = new calendar2(document." + formName + "." + name +
		"_yR);\n" + name + "_cal.target2 = document." + formName +
		"." + name + "_mO;\n" + name +
		"_cal.target3 = document." + formName +
		"." + name + "_dA;\n" + name + "_cal.year_scroll = true;\n" +
		name + "_cal.time_comp = false;\n</script>\n");
    }

    return sb;
  }

  /** Ask the form to record the current form value which has been
      entered for its field.  If the form returns a null value, the
      field was not mentioned in the form so the form has no effect on
      this selector object.  If the field returns a different value,
      however, the dirty bit is set to indicate that the field must be
      written to the database.  There is one exception - if the field
      has a null value and the form returns an empty string, this is
      not regarded as a change.
  @param request from the form wich may have a parameter whose name
  matches the name of this object, in which case the parameter value
  replaces the current choice.*/
  public void setChoice(HttpServletRequest request) {
    String aParam;
    /**/

    aParam = this.fieldNamePrefix + this.name;

    aParam = this.ReadDateSelectors(aParam, request, this.beginsInterval);
    this.setDirtyChoice(aParam);
    //System.out.println(this.name + " " + aParam + " " + this.choice);
  }

  /** Express the field in .html without labeling it, using a
      specified width. */
  public StringBuffer getHTMLOnly() {
    if (readOnly) { return new StringBuffer(getChoiceAsText()); }
    return this.getHTMLOnly(0);
  }

  /** Express the field in .html without labeling it, using a
      specified width. */
  public StringBuffer getHTMLOnly(int width) {
    StringBuffer sb;
    String cho = ES;
    /**/

    if (readOnly) { return new StringBuffer(getChoiceAsText()); }

    if (this.choice != null) {
      cho = this.choice;
    }
    return this.MakeDateSelectors(cho, this.fieldNamePrefix + this.name,
				  this.firstYear, this.lastYear);
  }

  /** Express the field as labeled .html. */
  public StringBuffer getHTML() {
    return this.getHTML(0);
  }

   /** Express the field as labeled .html. */
  public StringBuffer getHTML( int width) {
    StringBuffer sb;
    String cho = ES;
    /**/

    if (this.choice != null) {
      cho = this.choice;
    }
    sb = new StringBuffer(this.getPrettyName() + ": ");
    if (readOnly) {
      sb.append(getChoiceAsText()); // Uneditable
    } else {
      sb.append(this.getHTMLOnly(width));
    }
    return sb;
  }

  /** Set the choice string to indicate the present; this sets the
   * dirty flag because it is assumed to constitute a change.*/
  public void setChoiceToNow() {
    this.setDirtyChoice(SelectorFieldPreload.SQL_DATE_STRING.format(new Date()));
  }

  /** Move the time in the current choice based on the type and value
   * passed in.
   @param selector one of the Calendar class field selector values
   such as <CODE>Calendar.DAY_OF_MONTH</code> which determines which
   field to adjust.
  @param amount amount by which to adjust the date, negative values
  adjust into the past*/
  public void adjustChoiceSomehow(int selector, int amount) {
    GregorianCalendar cal;
    Date dat;
    /**/

    try {
      dat = SelectorFieldPreload.SQL_DATE_STRING.parse(this.getChoice());
    } catch (Exception e) {
      dat = new Date();
    }
    cal = new GregorianCalendar();
    cal.setTime(dat);
    cal.add(selector, amount);
    if (this.beginsInterval) {
      cal.set(Calendar.HOUR_OF_DAY, 0);
      cal.set(Calendar.MINUTE, 0);
      cal.set(Calendar.SECOND, 0);
    } else {
      cal.set(Calendar.HOUR_OF_DAY, 23);
      cal.set(Calendar.MINUTE, 59);
      cal.set(Calendar.SECOND, 59);
    }
    this.setDirtyChoice(SelectorFieldPreload.SQL_DATE_STRING.format(cal.getTime()));
  }

  /** Move the time forward or backward some number of days
      @param amount number of days to move, negative moves earlier*/
  public void adjustDays(int amount) {
    this.adjustChoiceSomehow(Calendar.DAY_OF_MONTH, amount);
  }

  /**
   * A date time string in SQL cannot be empty, it must be 0 to be
   * inserted in the database. */
  public String getChoice() {
    return ((this.choice == null) ? "0" : this.choice);
  }

  /** Get a read-only string which is suitable for inclusion in a
   * .html table.  This is used when the intent is to display the date
   *  but not to let it be edited.*/
  public String getChoiceAsText() {
    String val = this.getChoice(); // make sure it is not null
    /**/

    if (val.startsWith("0") || ES.equals(val)) { return "&nbsp;"; }
    try {
      return val.substring(5,7) + "/" + val.substring(8,10) + "/" +
	val.substring(2,4);
    } catch (Exception e) {}
    return "&nbsp;";
  }

  /** Dates and times may define intervals which are generally
      inclusive, that is, a day which defines the beginning of an
      interval must be converted into a time of 00:00:00 on that day
      whereas a day which ends an interval must be converted to 23:59:59
      on that day.  This flag determines whether a date/time field
      should begin an interval, the default is to end an interval.  If
      this flag is false, a DateTime is converted to 23:59:59 on the day,
      if it is true, that is, the day begins an interval, it is
      converted to 00:00:00 on that day.
  @param begins true means that the interval begins a day, */
  public void setBeginsInterval(boolean begins) {
    this.beginsInterval = begins;
  }

  /** Dates and times may define intervals which are generally
      inclusive, that is, a day which defines the beginning of an
      interval must be converted into a time of 00:00:00 on that day
      whereas a day which ends an interval must be converted to 23:59:59
      on that day.  This flag determines whether a date/time field
      should begin an interval, the default is to end an interval.  If
      this flag is false, a DateTime is converted to 23:59:59 on the day,
      if it is true, that is, the day begins an interval, it is
      converted to 00:00:00 on that day.
  @return true means that the interval begins a day, */
  public boolean getBeginsInterval() {
    return this.beginsInterval;
  }

  /** The year can be generated either as a field or as a pull-down.
   * If it is a pull down, it needs a starting year and the ending
   * year to put in the pull-down.  This method sets the first year.
   * The year is shown as a text field unless both the first year and
   * the last year are nonzero.
   @param year specifies the first year of the selector.*/
  public void setFirstYear(int year) {
    this.firstYear = year;
  }

  /** Return the first year of the selector. */
  public int getFirstYear () {
    return this.firstYear;
  }

  /** The year can be generated either as a field or as a pull-down.
   * If it is a pull down, it needs a starting year and the ending
   * year to put in the pull-down.  This method sets the last year in
   * the selector.  The year is shown as a text field unless both the
   * first year and the last year are nonzero.
   @param year specifies the last year in the selector.*/
  public void setLastYear(int year) {
    this.lastYear = year;
  }

  /** Return the last year of the selector. */
  public int getLastYear () {
    return this.lastYear;
  }

  /** Set the flag which indicates whether to use a pop-up calendar or
      not.  <B>NOTE:</b> Use of the pop-up calendar in a .jsp page
      requires the following:

      <UL>

      <LI>The calling .jsp page must include the JavaSWcript source
      code file <CODE>calendar1.js</code> which defines the actual
      pop-up. </li>

      <LI>The browser needs relative access to the
      <CODE>popcalimg</code> directory which stores the images needed
      by the popup calendar.</li>

      <LI>The browser must have relative access to the
      <CODE>calendar.html</code> file which sets the selected calendar
      value in the data fields of the calling .jsp page.</li>

      <LI>The caller must also use setFormName to specify the name of
      the .html form in which the <CODE>SelectorDatePreload</code>
      object is embedded.  This is because the generated .html code
      must refer to the form name and the fields within the form so
      that teh calendar pop-up can set the proper values based on the
      selected date.</li>

     </ul>
   @param usePopUp true -> offer a pop up calendar to enter the date
   or, in the case of the Datetime class which extends this class, the
   date and time.*/
  public void setUsePopUp (boolean usePopUp) {
    this.usePopUp = usePopUp;
  }

  /** Get the current value of the flag which indicates whether to use
   * a pop-up calendar or not.  The required files for using the
   * calendar pop-up are documented in {@link
   * asst.dbase.SelectorDatePreload#setUsePopUp(boolean usePopUp)
   * setUsePopUp }*/
  public boolean getUsePopUp() {
    return usePopUp;
  }

  /** Set the .html form name as required by {@link
   * asst.dbase.SelectorDatePreload#setUsePopUp(boolean usePopUp)
   * setUsePopUp }.  If this field is not set, the popup calendar will
   * not be able to set the form values properly.*/
  public void setFormName(String formName) {
    this.formName = formName;
  }

  /** Retrieve the form name as set by the caller.*/
  public String getFormName() {
    return formName;
  }

  /** Record whether the column value begins an interval.  This
   * determines how the hh:mm:ss part of the date string is set.*/
  protected boolean beginsInterval = false;

  /** Record whether the calendar data are entered using a pop-up
   * calendar.  This affects how the .html is generated.  */
  protected boolean usePopUp = false;

  /** Record the name of the form in which this object is being used.
   * The reason for this field is documented in {@link
   * asst.dbase.SelectorDatePreload#setUsePopUp(boolean usePopUp)
   * setUsePopUp }*/
  protected String formName;

  /** Record the first year in the selector.*/
  protected int firstYear = 0;

  /** Record the last year in the selector.*/
  protected int lastYear = 0;

}
